/// <reference types="big.js" />
import { ImageStyle } from 'react-native';
import { ImageURISource } from 'react-native';
import { ReactNode } from 'react';
import { TextStyle } from 'react-native';
import { ViewStyle } from 'react-native';

/**
 * Prop value representing an action, like {@link https://docs.mendix.com/refguide/action-button#events-on-click | On Click)
 * of an Action Button.
 *
 * @remarks
 * For a "Do nothing" action the component will receive `undefined` value instead.
 */
export declare interface ActionValue {
    /**
     * Whether an action can be executed under current circumstances.
     *
     * @example
     * A “Call a microflow” action triggering a microflow with a parameter cannot be executed until a parameter object
     * is available, e.g. when a parent Data view finished loading.
     *
     * @remark
     * This value does not depend on the current value of {@link isExecuting}, even if the {@link disabledDuringExecution}
     * flag is set to true.
     * @remark
     * An attempt to {@link execute} an action that cannot be executed will cause a DEBUG-level warning message.
     */
    readonly canExecute: boolean;
    /**
     * Indicates whether an action is currently running.
     *
     * @example
     * A long-running action like the “Call a microflow” action can take seconds to complete - way longer than
     * an expected UI response time. So your component might use this information to e.g. render an inline loading
     * indicator to match UX expectations.
     *
     * Often it is not desirable to allow user to trigger multiple actions in parallel - hence, a component (maybe based
     * on a configuration) can decide to skip triggering a new action while previous one is still running.
     *
     * @remark
     * It indicates only whether the current action is running. It does not indicate whether a target Nanoflow,
     * Microflow, or object operation like Save is running due to e.g. another action.
     */
    readonly isExecuting: boolean;
    /* Excluded from this release type: disabledDuringExecution */
    /**
     * Triggers the action.
     *
     * @remark
     * It returns nothing and does not guarantee that the action will be started synchronously. But when it actually
     * starts, the widget will receive a new prop with the {@link isExecuting} flag set.
     * @remark
     * An action can only be executed if {@link canExecute} is true. Additionally, if the {@link disabledDuringExecution}
     * flag is set, it can only be executed if it is not already executing. An attempt to execute an action that cannot
     * be executed will cause a DEBUG-level warning message.
     */
    execute(): void;
}

declare type AttributeValue_2 = PrimitiveAttributeValue_2 | GUID_2 | GUID_2[];

declare type BigJS_2 = BigJs.Big;

declare interface CustomDateTimeFormatterConfig {
    readonly type: "custom";
    readonly pattern: string;
}

declare interface CustomStyle {
    [key: string]: string | number;
}

/**
 * Built-in formatter/parser for editable date/time values (represented by the {@link Date} type). This formatter type
 * supports configuration options for date/time formatting and parsing. It also allows a fallback date to be passed as
 * a second argument to the {@link parse} method.
 */
declare interface DateTimeFormatter extends TypedFormatter<Date> {
    /**
     * Identifies this formatter as a {@link DateTimeFormatter} within the {@link ValueFormatter} union type.
     */
    readonly type: FormatterType.DateTime;
    /**
     * The configuration of this formatter.
     */
    readonly config: DateTimeFormatterConfig;
    /**
     * Parses the given display value.
     *
     * @param value The value to parse.
     * @param fallbackValue The fallback date to use when parsing, which may be omitted.
     *
     * @return A {@link ParseResult} indicating whether the parser could produce a valid result.
     */
    parse(value: string, fallbackValue?: Date): ParseResult<Date>;
    /**
     * Creates a formatter/parser for date and time with the given configuration options.
     *
     * @param config The new configuration options to use.
     *
     * @return A new {@link DateTimeFormatter}.
     *
     * @remark
     * Note that this function does not alter the existing formatter in any way, it only returns a new one with a
     * different configuration.
     */
    withConfig(config: DateTimeFormatterConfig): DateTimeFormatter;
    /**
     * @return A placeholder text matching the date/time pattern of this formatter.
     */
    getFormatPlaceholder(): Option_2<string>;
}

declare type DateTimeFormatterConfig = DefaultDateTimeFormatterConfig | CustomDateTimeFormatterConfig;

declare interface DefaultDateTimeFormatterConfig {
    readonly type: "date" | "time" | "datetime";
}

/**
 * Prop value representing a dynamically loaded value which may not always be available, as expressed by its {@link ValueStatus}.
 *
 * @property status The current status of the value.
 * @property value The value, if available, or the previous value when currently loading.
 *
 * @typeParam T The type of the contained value.
 */
export declare type DynamicValue<T> = {
    readonly status: ValueStatus.Available;
    readonly value: T;
} | {
    readonly status: ValueStatus.Unavailable;
    readonly value: undefined;
} | {
    readonly status: ValueStatus.Loading;
    readonly value: Option_2<T>;
};

/**
 * Prop value representing an editable value with formatting, parsing and validation. Like {@link DynamicValue}, this
 * value has a {@link ValueStatus}. Additionally, the value may be in a {@link readOnly} state which prevents editing.
 *
 * @typeParam T The type of the contained value, which must be a subtype of {@link AttributeValue}.
 */
export declare interface EditableValue<T extends AttributeValue_2> {
    /**
     * The current status of the value.
     */
    readonly status: ValueStatus;
    /**
     * Whether the value is read-only.
     *
     * @example
     * A read-only value can be the result of access restrictions or the current {@link status}.
     *
     * @remark
     * An attempt to call {@link setTextValue} or {@link setValue} while the value is read-only will cause a DEBUG-level
     * warning message.
     */
    readonly readOnly: boolean;
    /**
     * The value, if available, or the previous value when currently loading.
     */
    readonly value: Option_2<T>;
    /**
     * The formatted text value for the current value, as produced by {@link formatter}.
     *
     * @remark
     * To change the format, use {@link setFormatter}.
     */
    readonly displayValue: string;
    /**
     * Sets the value directly without parsing.
     *
     * @param value The new value.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     * @remark
     * An attempt to call this function while the value is read-only will cause a DEBUG-level warning message.
     */
    setValue(value: Option_2<T>): void;
    /**
     * Sets the text value, which will be parsed using the current {@link formatter} to produce the new internal value.
     *
     * If the text value is invalid, this will result in a {@link validation} message.
     *
     * @param value The new text value.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     * @remark
     * An attempt to call this function while the value is read-only will cause a DEBUG-level warning message.
     */
    setTextValue(value: string): void;
    /**
     * The validation message, if the value is currently invalid.
     *
     * @example
     * A validation message will be set if a text value cannot be parsed by the current {@link formatter} or if the
     * parsed value is invalid for its attribute or rejected by a validation expression.
     *
     * @remark
     * To set a custom validator, use {@link setValidator}.
     */
    readonly validation: Option_2<string>;
    /**
     * Sets a custom validator function.
     *
     * @param validator The new custom validator, or `undefined` to clear it.
     *
     * @remark
     * The custom validator does not replace the other types of validations which occur when the value is changed.
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    setValidator(validator?: (value: Option_2<T>) => Option_2<string>): void;
    /**
     * The formatter used to generate the {@link displayValue} from the current {@link value}.
     */
    readonly formatter: ValueFormatter<T>;
    /**
     * Sets the formatter used to generate the {@link displayValue}.
     *
     * @param formatter The new formatter to use, or `undefined` to revert to the default formatter.
     *
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    setFormatter(formatter: Option_2<ValueFormatter<T>>): void;
    /**
     * The universe of possible values for this editable value.
     *
     * @example
     * `Enum` and `Boolean` attributes have a fixed set of possible values, which a component may want to offer as
     * options to the user.
     */
    readonly universe?: T[];
}

/**
 * Prop value representing a file
 */
export declare interface FileValue {
    /**
     * The file's unique resource identifier
     */
    readonly uri: string;
    /**
     * The file's name including extension
     */
    readonly name: string;
}

/**
 * Built-in formatter type constants, identifying {@link NumberFormatter} and {@link DateTimeFormatter}.
 */
declare enum FormatterType {
    Number = "number",
    DateTime = "datetime"
}

declare interface GlyphIcon {
    readonly type: "glyph";
    readonly iconClass: string;
}

declare type GUID_2 = string & {
    __guidTag: any;
};

/**
 * Prop value representing all possible types of icons in the pluggable widget platform.
 */
export declare type IconValue = WebIcon | NativeIcon;

/**
 * Prop value representing images in the pluggable widget platform.
 */
export declare type ImageValue = WebImage | NativeImage;

declare interface InvalidParseResult {
    readonly valid: false;
}

export declare type ListActionValue = (item: ObjectItem) => ActionValue;

export declare type ListAttributeValue<T extends AttributeValue_2> = (item: ObjectItem) => EditableValue<T>;

/**
 * Prop value representing a list of objects, where each object is represented by an {@link ObjectItem}.
 * Like {@link DynamicValue}, this value has a {@link ValueStatus} which indicates whether the list is available.
 * It also provides control over the offset and limit used when retrieving data. The offset and limit are preserved
 * during navigation.
 */
export declare interface ListValue {
    /**
     * The current status of the list.
     */
    readonly status: ValueStatus;
    /**
     * A non-negative integer (zero-based) representing the offset that was last used to retrieve data.
     */
    readonly offset: number;
    /**
     * A non-negative integer representing the limit that was last used to retrieve data.
     */
    readonly limit: number;
    /**
     * Sets the offset to the given value. If the offset is different from the current offset, this will trigger a
     * request for a new {@link ListValue}.
     *
     * @param offset A non-negative integer (zero-based) representing the new offset.
     *
     * @remark
     * If the given offset is not a non-negative integer, an error will be thrown.
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    setOffset(offset: number): void;
    /**
     * Sets the limit to the given value. If the limit is different from the current limit, this will trigger a
     * request for a new {@link ListValue}. Passing {@code undefined} will reset the limit to its default value.
     *
     * @param limit A non-negative integer (zero-based) representing the new limit, or {@code undefined}.
     *
     * @remark
     * If the given limit is neither a non-negative integer nor {@code undefined}, an error will be thrown.
     * @remark
     * This function returns nothing, but will cause the widget to receive new props.
     */
    setLimit(limit: Option_2<number>): void;
    /**
     * The most recent list of objects, if available.
     *
     * @remark This property is always present when the status is available and optionally present when loading.
     */
    readonly items?: ObjectItem[];
    /**
     * Indicates whether there are more objects beyond the limit of the most recent list, if available.
     *
     * @remark
     * This property is always present when the status is available and optionally present when loading.
     */
    readonly hasMoreItems?: boolean;
    /**
     * The total number of available objects, if available.
     *
     * @remark The presence of this property depends on the current status and whether the data source supports a full
     * count.
     */
    readonly totalCount?: number;
}

export declare type ListWidgetValue = (item: ObjectItem) => ReactNode;

/**
 * Prop value representing all possible types of icons for the native platform.
 *
 * @property type The type of icon: `"glyph"` or `"image"`.
 * @property iconUrl The image source for the icon (only for {@link type} `"image"`).
 * @property iconClass The class for the glyph icon (only for {@link type} `"glyph"`).
 */
export declare type NativeIcon = GlyphIcon | NativeImageIcon | undefined;

/**
 * Prop value representing images for the native platform.
 *
 * @see ImageURISource
 */
export declare type NativeImage = Readonly<ImageURISource | string | number>;

declare interface NativeImageIcon {
    readonly type: "image";
    readonly iconUrl: Readonly<ImageURISource | string>;
}

/**
 * Built-in formatter/parser for editable number values (represented by the {@link BigJS} type). This formatter type
 * supports configuration options for number formatting and parsing.
 */
declare interface NumberFormatter extends TypedFormatter<BigJS_2> {
    /**
     * Identifies this formatter as a {@link NumberFormatter} within the {@link ValueFormatter} union type.
     */
    readonly type: FormatterType.Number;
    /**
     * The configuration of this formatter.
     */
    readonly config: NumberFormatterConfig;
    /**
     * Creates a formatter/parser for numbers with the given configuration options.
     *
     * @param config The new configuration options to use.
     *
     * @return A new {@link NumberFormatter}.
     *
     * @remark
     * Note that this function does not alter the existing formatter in any way, it only returns a new one with a
     * different configuration.
     */
    withConfig(config: NumberFormatterConfig): NumberFormatter;
}

declare interface NumberFormatterConfig {
    readonly groupDigits: boolean;
    readonly decimalPrecision?: number;
}

/**
 * An object item returned by a data source. This object does not provide direct access to any data attributes, but it
 * can be passed to various API functions (like a widgets template).
 *
 * @property id The {@link GUID} of the object.
 */
export declare interface ObjectItem {
    id: GUID_2;
}

declare type Option_2<T> = T | undefined;

/**
 * @property valid Whether the value was parsed successfully.
 * @property value The parsed value, if successful.
 *
 * @typeParam TVal The type of the parsed value.
 */
declare type ParseResult<TVal> = ValidParseResult<TVal> | InvalidParseResult;

/**
 * Type representing all possible prop values in the pluggable widget platform.
 */
export declare type PluginWidgetProp = PrimitiveValue | PrimitiveValue[] | ReactNode | ActionValue | DynamicValue<AttributeValue_2 | FileValue | ImageValue | IconValue> | EditableValue<AttributeValue_2> | ListValue | ListActionValue | ListAttributeValue<AttributeValue_2> | ListWidgetValue | PluginWidgetProps | PluginWidgetProps[];

/**
 * Collection of all props for a pluggable widget.
 */
export declare interface PluginWidgetProps {
    [name: string]: PluginWidgetProp;
}

declare type PrimitiveAttributeValue_2 = undefined | string | boolean | Date | BigJS_2;

/**
 * Primitive prop values in the pluggable widget platform.
 */
export declare type PrimitiveValue = number | string | boolean | null;

/**
 * Simple formatter/parser for editable values, without any configuration options.
 *
 * @typeParam T The type of the parsed value.
 */
declare interface SimpleFormatter<T> {
    /**
     * Formats the given value as text.
     *
     * @param value The value to format.
     */
    format(value?: T): string;
    /**
     * Parses the given display value.
     *
     * @param value The value to parse.
     *
     * @return A {@link ParseResult} indicating whether the parser could produce a valid result.
     */
    parse(value: string): ParseResult<T>;
}

export declare interface Style {
    [key: string]: CustomStyle | ViewStyle | TextStyle | ImageStyle;
}

declare interface TypedFormatter<T> extends SimpleFormatter<T> {
    readonly type: FormatterType;
}

declare interface ValidParseResult<TVal> {
    readonly valid: true;
    readonly value?: TVal;
}

/**
 * Formatter/parser for editable values, either a built-in formatter with configuration options ({@link NumberFormatter}
 * or {@link DateTimeFormatter}) or a {@link SimpleFormatter}.
 *
 * @property type A {@link FormatterType} constant identifying the built-in formatter type, if set.
 *
 * @typeParam T The type of the parsed value.
 *
 * @remark
 * The `type` property can be used as a type guard to narrow this union type to a specific built-in formatter type.
 */
declare type ValueFormatter<T> = (TypedFormatter<T> & (NumberFormatter | DateTimeFormatter)) | (SimpleFormatter<T> & {
    readonly type?: never;
});

/**
 * Expresses the status of a {@link DynamicValue}.
 */
export declare const enum ValueStatus {
    /**
     * The value is available, up to date, and can be used.
     */
    Available = "available",
    /**
     * The value is unavailable and won't be, at least until some significant change like user interaction happens.
     *
     * @example
     * When {@link DynamicValue} represents a value of a {@link https://docs.mendix.com/refguide/text#text-template | Text template}
     * with parameters dependent on the context, but the parent Data view has no object, then that value cannot be
     * computed and is marked as unavailable.
     */
    Unavailable = "unavailable",
    /**
     * The value is temporary unavailable or outdated.
     *
     * @example
     * When {@link DynamicValue} represents a value of a {@link https://docs.mendix.com/refguide/text#text-template | Text template}
     * with parameters dependent on the context, but the parent Data view is still waiting for its object to arrive or
     * is refreshing its Data source due to {@link https://docs.mendix.com/refguide/change-object#3-2-refresh-in-client | refresh in client},
     * then the value is marked as loading.
     */
    Loading = "loading"
}

/**
 * Prop value representing all possible types of icons for the web platform.
 *
 * @property type The type of icon: `"glyph"` or `"image"`.
 * @property iconUrl The image source for the icon (only for {@link type} `"image"`).
 * @property iconClass The CSS class for the glyph icon (only for {@link type} `"glyph"`).
 */
export declare type WebIcon = GlyphIcon | WebImageIcon | undefined;

/**
 * Prop value representing images for the web platform.
 *
 * @property uri The source URI for the image.
 * @property altText The alternative text for the image.
 * @property name The image file name.
 */
export declare interface WebImage {
    readonly uri: string;
    readonly name: string;
    readonly altText?: string;
}

declare interface WebImageIcon {
    readonly type: "image";
    readonly iconUrl: string;
}

export { }
