"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const xml2js_1 = require("xml2js");
const list_action_1 = require("./inputs/list-action");
const list_action_2 = require("./outputs/list-action");
const list_image_1 = require("./inputs/list-image");
const list_image_2 = require("./outputs/list-image");
const icon_1 = require("./inputs/icon");
const icon_2 = require("./outputs/icon");
const containment_1 = require("./inputs/containment");
const containment_2 = require("./outputs/containment");
const file_1 = require("./inputs/file");
const file_2 = require("./outputs/file");
const list_files_1 = require("./inputs/list-files");
const list_files_2 = require("./outputs/list-files");
const datasource_1 = require("./inputs/datasource");
const datasource_2 = require("./outputs/datasource");
const generate_1 = require("../generate");
const generateClientTypes_1 = require("../generateClientTypes");
const helpers_1 = require("../helpers");
const inputs_1 = require("./inputs");
const outputs_1 = require("./outputs");
describe("Generating tests", () => {
    it("Generates a parsed typing from XML for native", () => {
        const newContent = generateFullTypesFor(inputs_1.contentNative);
        expect(newContent).toBe(outputs_1.nativeResult);
    });
    it("Generates a parsed typing from XML for web", () => {
        const newContent = generateFullTypesFor(inputs_1.content);
        expect(newContent).toBe(outputs_1.webResult);
    });
    it("Generates a parsed typing from XML for native with groups", () => {
        const newContent = generateFullTypesFor(inputs_1.contentGroupNative);
        expect(newContent).toBe(outputs_1.nativeResult);
    });
    it("Generates a parsed typing from XML for web with groups", () => {
        const newContent = generateFullTypesFor(inputs_1.contentGroup);
        expect(newContent).toBe(outputs_1.webResult);
    });
    it("Generates a parsed typing from XML for native using list of actions", () => {
        const newContent = generateNativeTypesFor(list_action_1.listActionInputNative);
        expect(newContent).toBe(list_action_2.listActionNativeOutput);
    });
    it("Generates a parsed typing from XML for web using list of actions", () => {
        const newContent = generateFullTypesFor(list_action_1.listActionInput);
        expect(newContent).toBe(list_action_2.listActionWebOutput);
    });
    it("Generates a parsed typing from XML for native using list of images", () => {
        const newContent = generateNativeTypesFor(list_image_1.listImageInputNative);
        expect(newContent).toBe(list_image_2.listImageNativeOutput);
    });
    it("Generates a parsed typing from XML for web using list of images", () => {
        const newContent = generateFullTypesFor(list_image_1.listImageInput);
        expect(newContent).toBe(list_image_2.listImageWebOutput);
    });
    it("Generates a parsed typing from XML for native using icons", () => {
        const newContent = generateNativeTypesFor(icon_1.iconInputNative);
        expect(newContent).toBe(icon_2.iconNativeOutput);
    });
    it("Generates a parsed typing from XML for web using icons", () => {
        const newContent = generateFullTypesFor(icon_1.iconInput);
        expect(newContent).toBe(icon_2.iconWebOutput);
    });
    it("Generates a parsed typing from XML for web using containment", () => {
        const newContent = generateFullTypesFor(containment_1.containmentInput);
        expect(newContent).toBe(containment_2.containmentWebOutput);
    });
    it("Generates a parsed typing from XML for native using containment", () => {
        const newContent = generateNativeTypesFor(containment_1.containmentInputNative);
        expect(newContent).toBe(containment_2.containmentNativeOutput);
    });
    it("Generates a parsed typing from XML for web using file", () => {
        const newContent = generateFullTypesFor(file_1.fileInput);
        expect(newContent).toBe(file_2.fileWebOutput);
    });
    it("Generates a parsed typing from XML for native using file", () => {
        const newContent = generateNativeTypesFor(file_1.fileInputNative);
        expect(newContent).toBe(file_2.fileNativeOutput);
    });
    it("Generates a parsed typing from XML for web using a list of file", () => {
        const newContent = generateFullTypesFor(list_files_1.listFileInput);
        expect(newContent).toBe(list_files_2.listFileWebOutput);
    });
    it("Generates a parsed typing from XML for native using a list of file", () => {
        const newContent = generateNativeTypesFor(list_files_1.listFileInputNative);
        expect(newContent).toBe(list_files_2.listFileNativeOutput);
    });
    it("Generates a parsed typing from XML for web using datasource", () => {
        const newContent = generateFullTypesFor(datasource_1.datasourceInput);
        expect(newContent).toBe(datasource_2.datasourceWebOutput);
    });
    it("Generates a parsed typing from XML for native using datasource", () => {
        const newContent = generateNativeTypesFor(datasource_1.datasourceInputNative);
        expect(newContent).toBe(datasource_2.datasourceNativeOutput);
    });
});
function generateFullTypesFor(xml) {
    return generate_1.generateForWidget(convertXmltoJson(xml), "MyWidget");
}
function generateNativeTypesFor(xml) {
    const widgetXml = convertXmltoJson(xml);
    return generateClientTypes_1.generateClientTypes("MyWidget", helpers_1.extractProperties(widgetXml.widget.properties[0]), true).join("\n\n");
}
function convertXmltoJson(xml) {
    let content = {};
    if (xml) {
        xml2js_1.parseString(xml, {}, (err, result) => {
            if (err) {
                throw err;
            }
            content = result;
        });
    }
    return content;
}
