"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toClientType = exports.generateClientTypes = void 0;
const helpers_1 = require("./helpers");
function generateClientTypes(widgetName, properties, isNative) {
    const results = Array.of();
    results.push(isNative
        ? `export interface ${widgetName}Props<Style> {
    name: string;
    style: Style[];
${generateClientTypeBody(properties, true, results)}
}`
        : `export interface ${widgetName}ContainerProps {
    name: string;
    class: string;
    style?: CSSProperties;
    tabIndex: number;
${generateClientTypeBody(properties, false, results)}
}`);
    return results;
}
exports.generateClientTypes = generateClientTypes;
function generateClientTypeBody(properties, isNative, generatedTypes) {
    return properties
        .map(prop => {
        const isOptional = prop.$.type !== "string" &&
            ((prop.$.required === "false" && prop.$.type !== "object") || prop.$.type === "action");
        return `    ${prop.$.key}${isOptional ? "?" : ""}: ${toClientPropType(prop, isNative, generatedTypes)};`;
    })
        .join("\n");
}
function toClientPropType(prop, isNative, generatedTypes) {
    var _a, _b;
    switch (prop.$.type) {
        case "boolean":
            return "boolean";
        case "string":
            return "string";
        case "action":
            return prop.$.dataSource ? "ListActionValue" : "ActionValue";
        case "textTemplate":
            return "DynamicValue<string>";
        case "integer":
            return "number";
        case "decimal":
            return "BigJs.Big";
        case "icon":
            return isNative ? "DynamicValue<NativeIcon>" : "DynamicValue<WebIcon>";
        case "image":
            return isNative ? "DynamicValue<NativeImage>" : "DynamicValue<WebImage>";
        case "file":
            return "DynamicValue<FileValue>";
        case "datasource":
            return "ListValue";
        case "attribute":
            if (!((_a = prop.attributeTypes) === null || _a === void 0 ? void 0 : _a.length)) {
                throw new Error("[XML] Attribute property requires attributeTypes element");
            }
            const types = prop.attributeTypes
                .map(ats => ats.attributeType)
                .reduce((a, i) => a.concat(i), [])
                .map(at => toClientType(at.$.name));
            const uniqueTypes = Array.from(new Set(types));
            return prop.$.dataSource
                ? `ListAttributeValue<${uniqueTypes.join(" | ")}>`
                : `EditableValue<${uniqueTypes.join(" | ")}>`;
        case "expression":
            if (!prop.returnType || prop.returnType.length === 0) {
                throw new Error("[XML] Expression property requires returnType element");
            }
            return `DynamicValue<${toClientType(prop.returnType[0].$.type)}>`;
        case "enumeration":
            const typeName = helpers_1.capitalizeFirstLetter(prop.$.key) + "Enum";
            generatedTypes.push(generateEnum(typeName, prop));
            return typeName;
        case "object":
            if (!((_b = prop.properties) === null || _b === void 0 ? void 0 : _b.length)) {
                throw new Error("[XML] Object property requires properties element");
            }
            const childType = helpers_1.capitalizeFirstLetter(prop.$.key) + "Type";
            generatedTypes.push(`export interface ${childType} {
${generateClientTypeBody(helpers_1.extractProperties(prop.properties[0]), isNative, generatedTypes)}
}`);
            return prop.$.isList === "true" ? `${childType}[]` : childType;
        case "widgets":
            return prop.$.dataSource ? "ListWidgetValue" : "ReactNode";
        default:
            return "any";
    }
}
function generateEnum(typeName, prop) {
    var _a, _b;
    if (!((_a = prop.enumerationValues) === null || _a === void 0 ? void 0 : _a.length) || !((_b = prop.enumerationValues[0].enumerationValue) === null || _b === void 0 ? void 0 : _b.length)) {
        throw new Error("[XML] Enumeration property requires enumerations element");
    }
    const members = prop.enumerationValues[0].enumerationValue.map(type => `"${type.$.key}"`);
    return `export type ${typeName} = ${members.join(" | ")};`;
}
function toClientType(xmlType) {
    switch (xmlType) {
        case "Boolean":
            return "boolean";
        case "DateTime":
            return "Date";
        case "AutoNumber":
        case "Decimal":
        case "Integer":
        case "Long":
            return "BigJs.Big";
        case "HashString":
        case "String":
        case "Enum":
            return "string";
        default:
            return "any";
    }
}
exports.toClientType = toClientType;
